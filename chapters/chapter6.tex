\chapter{预处理}

\section{预处理}

\subsection{宏（Macro）}

宏是一种简单的文本替换工具，可以用于定义一个特定的常量或表达式，一般用大写表示。宏定义使用\#define指令，在编译期间，编译器会将程序中所有的宏替换为其内容。\\

与变量的定义不同的是，宏没有类型，也不占内存空间。\\

\mybox{圆}

\begin{lstlisting}[language=C]
#include <stdio.h>

#define PI 3.14159

double perimeter(double r) {
    return 2 * PI * r;
}

double area(double r) {
    return PI * r * r;
}

int main() {
    double radius;
    printf("Enter radius: ");
    scanf("%lf", &radius);

    printf("Perimeter: %.2f\n", perimeter(radius));
    printf("Area: %.2f\n", area(radius));

    return 0;
}
\end{lstlisting}

\begin{tcolorbox}
    \mybox{运行结果}
    \begin{verbatim}
Enter radius: 5
Perimeter: 31.42
Area: 78.54
	\end{verbatim}
\end{tcolorbox}

宏也可以像函数一样传递参数，但是宏的参数不会进行类型检查，宏最终同样也会在编译期间被展开。\\

但是由于宏定义的内容在编译时会被替换到代码中，有时候会导致运算的优先级发生改变。

\vspace{-0.5cm}

\begin{lstlisting}[language=C]
#define SQUARE x * x
\end{lstlisting}

例如SQUARE(2 + 3)会被展开为2 + 3 * 2 + 3，而不是(2 + 3) * (2 + 3)。因此，最好在宏中使用括号来避免这种情况。

\vspace{-0.5cm}

\begin{lstlisting}[language=C]
#define SQUARE (x * x)
\end{lstlisting}

\vspace{0.5cm}

\subsection{条件编译}

条件编译是一种在编译时根据宏的定义来决定是否编译某段代码的方法。\\

\mybox{斐波那契数列}

\begin{lstlisting}[language=C]
#include <stdio.h>

#define RECURSION

#ifdef RECURSION
int fibonacci(int n) {
    if (n == 0) {
        return 0;
    } else if (n == 1) {
        return 1;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}
#else
int fibonacci(int n) {
    int seq[n];
    seq[0] = 0;
    seq[1] = 1;

    for (int i = 2; i <= n; i++) {
        seq[i] = seq[i - 1] + seq[i - 2];
    }

    return seq[n];
}
#endif

int main() {
    int n;
    printf("Enter n: ");
    scanf("%d", &n);

    printf("%d\n", fibonacci(n));
    return 0;
}
\end{lstlisting}

\begin{tcolorbox}
    \mybox{运行结果}
    \begin{verbatim}
Enter n: 7
13
	\end{verbatim}
\end{tcolorbox}

\newpage

\section{多文件编译}

\subsection{编译}