\chapter{指针}

\section{指针}

\subsection{指针（Pointer）}

每个变量都会在内存中占用一定的空间，不同类型的变量占用的空间大小也不同。每个空间都有一个地址，一般采用十六进制表示，如0x0060FEFC。\\

有时候需要通过变量的地址对变量进行操作，这时候就需要将变量的地址保存起来，保存地址的变量就成为指针。

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \draw (0,0) rectangle node{3} (1,1);
        \draw (0.5,1.5) node{data};
        \draw (0.5,-0.5) node{0x0060FEFC};

        \draw (5,0.5) circle (0.5);
        \draw (5,1.5) node{p};
        \draw (5,-0.5) node{0x0060FEF8};

        \draw[->] (5,0.5) -- (1,0.5);
    \end{tikzpicture}
\end{figure}

*用于声明一个指针变量，例如int *p表示p是一个指针，指向一个int类型的变量的地址。通过取地址运算符\&可以获取变量的地址，占位符\%p能够以十六进制的形式输出地址。\\

既然指针保存了另一个变量的地址，那么通过指针就可以访问到那个变量上的数据。在指针变量前使用*运算符，就可以获取到指针所指向的变量的值。

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \draw (0,0) rectangle node{5} (1,1);
        \draw (0.5,1.5) node{data};
        \draw (0.5,-0.5) node{0x0060FEFC};

        \draw (5,0.5) circle (0.5);
        \draw (5,1.5) node{p};
        \draw (5,-0.5) node{0x0060FEF8};

        \draw[->] (5,0.5) -- (1,0.5);
    \end{tikzpicture}
\end{figure}

\mybox{指针}

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int data = 3;
    int *p = &data;

    printf("Value of data: %d\n", data);
    printf("Address of data: %p\n", &data);
    
    printf("Value of p: %p\n", p);
    printf("Address of p: %p\n", &p);
    printf("Value of data pointed by p: %d\n", *p);
    
    *p = 5;

    printf("Value of data: %d\n", data);
    printf("Value of data pointed by p: %d\n", *p);

    return 0;
}
\end{lstlisting}

\begin{tcolorbox}
    \mybox{运行结果}
    \begin{verbatim}
Value of data: 3
Address of data: 000000000061FE1C
Value of p: 000000000061FE1C     
Address of p: 000000000061FE10   
Value of data pointed by p: 3
Value of data: 5
Value of data pointed by p: 5
	\end{verbatim}
\end{tcolorbox}

为什么不直接修改变量的值，还要多此一举通过指针修改呢？\\

例如需要实现swap()用于交换两个变量的值，由于传递参数是按值传递（pass by value），所以交换的仅仅只是swap()中局部变量的值。\\

这种情况下就需要使用指针，将需要交换的变量的地址传递给swap()，然后在swap()中交换这两个地址上的值。\\

\mybox{交换}

\begin{lstlisting}[language=C]
#include <stdio.h>

void swap(int *data1, int *data2) {
    int temp = *data1;
    *data1 = *data2;
    *data2 = temp;
}

int main() {
    int a = 3;
    int b = 5;

    printf("Before: a = %d, b = %d\n", a, b);
    swap(&a, &b);
    printf("After: a = %d, b = %d\n", a, b);
    return 0;
}
\end{lstlisting}

\begin{tcolorbox}
    \mybox{运行结果}
    \begin{verbatim}
Before: a = 3, b = 5
After: a = 5, b = 3
	\end{verbatim}
\end{tcolorbox}

函数最多只能返回一个值，但如果需要有多个值需要返回，就可以使用指针将数据带回。\\

\mybox{一元二次方程}

\begin{lstlisting}[language=C]
#include <stdio.h>
#include <stdbool.h>
#include <math.h>

/**
 * Solve quadratic equation ax^2 + bx + c = 0.
 * @param a coefficient of x^2
 * @param b coefficient of x
 * @param c constant
 * @param x1 pointer to the first root
 * @param x2 pointer to the second root
 * @return true if the equation has real roots, false otherwise.
 */
bool solver(double a, double b, double c, double *x1, double *x2) {
    double delta = b * b - 4 * a * c;
    if (delta < 0) {
        return false;
    }
    *x1 = (-b + sqrt(delta)) / (2 * a);
    *x2 = (-b - sqrt(delta)) / (2 * a);
    return true;
}

int main() {
    double a, b, c;
    double x1, x2;

    printf("Quadratic equation ax^2 + bx + c = 0\n");
    printf("Enter coefficients a, b, c: ");
    scanf("%lf%lf%lf", &a, &b, &c);

    if (solver(a, b, c, &x1, &x2)) {
        printf("x1 = %.2f, x2 = %.2f\n", x1, x2);
    } else {
        printf("No real roots\n");
    }

    return 0;
}
\end{lstlisting}

\begin{tcolorbox}
    \mybox{运行结果}
    \begin{verbatim}
Quadratic equation ax^2 + bx + c = 0
Enter coefficients a, b, c: 1 -9 20
x1 = 5.00, x2 = 4.00
	\end{verbatim}
\end{tcolorbox}

\vspace{0.5cm}

\subsection{NULL}

如果一个变量声明时没有初始化，那么它的值是不确定的。声明指针时如果不对指针进行初始化，那么它就会指向一块不确定的内存地址，这种指针被称为野指针。\\

使用野指针可能会导致程序崩溃，因为它可能指向一个不可访问的内存地址。因此，如果指针没有指向一个确定的内存地址时，应该将其赋值为空指针NULL。

\vspace{-0.5cm}

\begin{lstlisting}[language=C]
int *p = NULL;
\end{lstlisting}

\newpage

\section{指针与数组}

\subsection{指针与数组}

数组变量本身就表达地址，所以无需使用【\&】取地址。

\vspace{-0.5cm}

\begin{lstlisting}[language=C]
int arr[10];
int *p = arr;
\end{lstlisting}

但是数组的每个单元表达的是变量，需要使用【\&】取地址。

\vspace{-0.5cm}

\begin{lstlisting}[language=C]
int arr[10];
int *p = &arr[0];
\end{lstlisting}

\vspace{0.5cm}

\mybox{指针遍历数组}

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int arr[] = {44, 12, 64, 78, 16, 72, 13, 98, 84};
    int n = sizeof(arr) / sizeof(arr[0]);
    int *p = arr;

    while(p < arr + n) {
        printf("%d ", *p);
        p++;
    }
    printf("\n");
    return 0;
}
\end{lstlisting}

\begin{tcolorbox}
    \mybox{运行结果}
    \begin{verbatim}
44 12 64 78 16 72 13 98 84
	\end{verbatim}
\end{tcolorbox}

\vspace{0.5cm}

\subsection{数组与函数}

在将数组作为函数参数传递的时候，在函数参数列表中的数组实际上是一个指向数组首地址的指针。\\

以下两种函数声明是等价的：

\vspace{-0.5cm}

\begin{lstlisting}[language=C]
int func(int arr[]);
int func(int *arr);
\end{lstlisting}

\vspace{0.5cm}

\mybox{查找数组最大值}

\begin{lstlisting}[language=C]
#include <stdio.h>

int getMax(int *arr, int n) {
    int max = arr[0];
    for(int i = 1; i < n; i++) {
        if(arr[i] > max) {
            max = arr[i];
        }
    }
    return max;
}

int main() {
    int arr[] = {76, 23, 12, 98, 5, 61, 30};
    int n = sizeof(arr) / sizeof(arr[0]);
    int max = getMax(arr, n);
    printf("max = %d\n" , max);
    return 0;
}
\end{lstlisting}

\begin{tcolorbox}
    \mybox{运行结果}
    \begin{verbatim}
max = 98
	\end{verbatim}
\end{tcolorbox}

\newpage

\section{指针与字符串}

\subsection{指针与字符串}

指针还可以指向一个字符串常量，但是试图通过指针所指的字符串做写操作会导致程序崩溃。\\

\mybox{修改字符串常量}

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    char *s = "hello";
    s[0] = 'H';
    printf("%s\n", s);
    return 0;
}
\end{lstlisting}

因此，如果需要对字符串进行修改，应该用字符数组的形式。\\

\mybox{修改字符串}

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    char s[] = "hello";
    s[0] = 'H';
    printf("%s\n", s);
    return 0;
}
\end{lstlisting}

\begin{tcolorbox}
    \mybox{运行结果}
    \begin{verbatim}
Hello
	\end{verbatim}
\end{tcolorbox}

在对一个指向字符串的指针进行赋值操作的时候，并没有产生新的字符串，只是让两个指针都指向该字符串，对其中任意一个指针做的操作都会对另一个指针产生影响。\\

\mybox{指向字符串的指针}

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    char str[] = "hello";
    char *s = str;
    char *t = s;
    s[0] = 'H';
    printf("指针s指向的字符串：%s\n", s);
    printf("指针t指向的字符串：%s\n", t);
    printf("指针s的地址：%p\n", &s);
    printf("指针t的地址：%p\n", &t);
    return 0;
}
\end{lstlisting}

\begin{tcolorbox}
    \mybox{运行结果}
    \begin{verbatim}
指针s指向的字符串：Hello
指针t指向的字符串：Hello
指针s的地址：0022FE40
指针t的地址：0022FE38
	\end{verbatim}
\end{tcolorbox}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \draw (-4,-5.5) rectangle (-2,-4.5);
        \draw (2,-5.5) rectangle (4,-4.5);
        \draw (-3,-4) node {s};
        \draw (3,-4) node {t};

        \draw (-1,-7) rectangle (1,-6);
        \draw[->] (-2,-5) -- (-1,-6.5);
        \draw[->] (2,-5) -- (1,-6.5);
    \end{tikzpicture}
    \caption{指向字符串的指针}
\end{figure}

\newpage

\section{动态内存申请}

\subsection{malloc()}

C99支持声明数组时使用变量作为数组的大小。

\vspace{-0.5cm}

\begin{lstlisting}[language=C]
int n = 50;
int arr[n];
\end{lstlisting}

但是在C99之前的版本中，需要使用动态内存申请的方式进行数组空间的开辟。malloc()的功能是向系统申请指定的内存空间（以字节为单位），使用该函数需要包含头文件stdlib.h。\\

malloc()函数原型为：

\vspace{-0.5cm}

\begin{lstlisting}[language=C]
void* malloc(size_t size);
\end{lstlisting}

malloc()的返回值为void *类型，表示一个指向申请到的空间的首地址，是一个无类型的指针，开发者需要自行转换为自己需要的类型。如果malloc()申请内存失败，则会返回空指针NULL。\\

\mybox{耗尽所有可申请到的内存空间}

\begin{lstlisting}[language=C]
#include <stdio.h>
#include <stdlib.h>

int main() {
    void *p;
    int cnt = 0;

    // 每次申请100MB的空间
    while((p = malloc(100 * 1024 * 1024))) {
        cnt++;
    }
    printf("一共分配了%dMB空间\n", cnt*100);
    return 0;
}
\end{lstlisting}

\begin{tcolorbox}
    \mybox{运行结果}
    \begin{verbatim}
一共分配了1900MB空间
	\end{verbatim}
\end{tcolorbox}

通过malloc()申请来的空间是需要归还给操作系统的，否则程序长时间运行内存会逐渐下降。\\

通过free()可以把申请来的空间释放，但是有两点需要注意：

\begin{enumerate}
    \item 只能释放通过malloc()申请得到的空间。
    \item 只能通过空间的首地址进行释放。
\end{enumerate}

\vspace{0.5cm}

\mybox{动态申请内存空间}

\begin{lstlisting}[language=C]
#include <stdio.h>
#include <stdlib.h>

int main() {
    int n;
    printf("班级人数：");
    scanf("%d", &n);

    int *scores = (int *)malloc(sizeof(int) * n);
    if(!scores) {
        fprintf(stderr, "内存申请失败\n");
        exit(1);
    }

    int total = 0;
    for(int i = 0; i < n; i++) {
        printf("第%d个学生成绩：", i+1);
        scanf("%d", &scores[i]);
        total += scores[i];
    }

    printf("平均分：%.2f\n", 1.0 * total / n);
    free(scores);
    return 0;
}
\end{lstlisting}

\begin{tcolorbox}
    \mybox{运行结果}
    \begin{verbatim}
班级人数：5
第1个学生成绩：67
第2个学生成绩：98
第3个学生成绩：100
第4个学生成绩：53
第5个学生成绩：65
平均分：76.60
	\end{verbatim}
\end{tcolorbox}

在函数中的定义的字符数组是局部变量，其作用域和生命周期仅在函数内有效，如果将其作为函数返回值返回，在函数外部无法访问到该变量的内容。\\

\mybox{函数返回字符串（Bug版本）}

\begin{lstlisting}[language=C]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/**
    * @brief  生成一段自我介绍
    * @param  name: 姓名
    * @param  age: 年龄
    * @retval 指定格式字符串：大家好，我叫{name}，今年{age}岁。
    */
char* generateInfo(char *name, int age) {
    char info[128] = "大家好，我叫";
    char age_str[8] = "";
    strcat(info, name);
    strcat(info, "，今年");
    // itoa()函数用于将整数转为字符串
    // 把age以10进制转换为字符串保存到age_str
    strcat(info, itoa(age, age_str, 10));
    strcat(info, "岁。");
    return info;
}

int main() {
    printf("%s\n", generateInfo("极夜酱", 17));
    return 0;
}
\end{lstlisting}

\begin{tcolorbox}
    \mybox{运行结果}
    \begin{verbatim}
warning:
function returns address of local variable [-Wreturn-local-addr]
	\end{verbatim}
\end{tcolorbox}

\vspace{0.5cm}

\mybox{函数返回字符串（正确版本）}

\begin{lstlisting}[language=C]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/**
    * @brief  生成一段自我介绍
    * @param  name: 姓名
    * @param  age: 年龄
    * @retval 指定格式字符串：大家好，我叫{name}，今年{age}岁。
    */
char* generateInfo(char *name, int age) {
    char *info = (char *)malloc(sizeof(char) * 128);
    if(!info) {
        return NULL;
    }
    char age_str[8] = "";
    strcpy(info, "大家好，我叫");
    strcat(info, name);
    strcat(info, "，今年");
    // itoa()函数用于将整数转为字符串
    // 把age以10进制转换为字符串保存到age_str
    strcat(info, itoa(age, age_str, 10));
    strcat(info, "岁。");
    return info;
}

int main() {
    printf("%s\n", generateInfo("极夜酱", 17));
    return 0;
}
\end{lstlisting}

\begin{tcolorbox}
    \mybox{运行结果}
    \begin{verbatim}
大家好，我叫极夜酱，今年17岁。
	\end{verbatim}
\end{tcolorbox}

\vspace{0.5cm}

\subsection{内存管理}

内存通常包括了栈区（stack）、堆区（heap）、数据区、程序代码区：

\begin{itemize}
    \item 栈区：由编译器自动分配和释放，存放函数的参数值、局部变量的值等。

    \item 堆区：一般由程序员分配和释放，若程序员不释放，程序结束后被OS回收。

    \item 数据区：存放全局变量和静态变量，程序结束后由系统释放。

    \item 程序代码区：存放函数体的二进制代码。
\end{itemize}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[scale=0.7]
        \draw[-] (0,0) -- (0,10) -- (5,10) -- (5,0) -- (0,0);
        \draw[-] (0,2) -- (5,2);
        \draw[-] (0,4) -- (5,4);
        \draw[-] (0,6) -- (5,6);
        \draw[-] (0,8) -- (5,8);

        \draw (0,0) node[left] {0};
        \draw (0,10) node[left] {max};

        \draw (2.5,1) node {Text};
        \draw (2.5,3) node {Data};
        \draw (2.5,5) node {Heap};
        \draw (2.5,9) node {Stack};

        \draw[->] (2.5,8) -- (2.5,7.5);
        \draw[->] (2.5,6) -- (2.5,6.5);
    \end{tikzpicture}
    \caption{内存管理}
\end{figure}

\newpage